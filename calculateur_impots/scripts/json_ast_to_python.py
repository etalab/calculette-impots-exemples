#!/usr/bin/env python3
# -*- coding: utf-8 -*-


"""
Transpile (roughly means convert) a JSON AST file to Python source code.
"""


from operator import itemgetter
import argparse
import copy
import glob
import itertools
import json
import logging
import os
import pprint
import sys
import textwrap

from toolz.curried import concat, concatv, filter, map, mapcat, pipe, sorted, valmap

from calculateur_impots import python_source_visitors


# Globals


args = None
script_name = os.path.splitext(os.path.basename(__file__))[0]
log = logging.getLogger(script_name)

script_dir_path = os.path.dirname(os.path.abspath(__file__))
generated_dir_path = os.path.abspath(os.path.join(script_dir_path, '..', 'generated'))


# Source code helper functions


def formulas_file_source(formulas_sources):
    return as_lines(concatv(
        (
            'from ..formulas_helpers import *',
            'from .constants import *\n',
            'def compute(base_variables, saisie_variables):',
            ),
        map(
            lambda formula_source: textwrap.indent(formula_source, prefix=4 * ' '),
            formulas_sources,
            ),
        (
            '    return locals()',
            ),
        ))


def as_lines(sequence):
    return ''.join(concat(zip(sequence, itertools.repeat('\n'))))


def read_ast_json_file(json_file_name):
    nodes = read_json_file(os.path.join('ast', json_file_name))
    assert isinstance(nodes, list)
    return nodes


def read_json_file(json_file_name):
    json_file_path = os.path.abspath(os.path.join(args.json_dir, json_file_name))
    log.info('Loading "{}"...'.format(json_file_path))
    with open(json_file_path) as json_file:
        json_str = json_file.read()
    return json.loads(json_str)


def write_source_file(file_name, source):
    header = """\
# -*- coding: utf-8 -*-
# flake8: noqa
# WARNING: This file is automatically generated by a script. No not modify it by hand!
"""
    file_path = os.path.join(generated_dir_path, file_name)
    with open(file_path, 'w') as output_file:
        output_file.write(as_lines((header, source)))
    log.info('Output file "{}" written with success'.format(file_path))


# Load files functions


def iter_ast_json_file_names(filenames, excluded_filenames=None):
    json_file_paths = pipe(
        filenames,
        mapcat(lambda pathname: glob.iglob(os.path.join(args.json_dir, 'ast', pathname))),
        filter(lambda file_path: excluded_filenames is None or os.path.basename(file_path) not in excluded_filenames),
        sorted,
        )
    for json_file_path in json_file_paths:
        json_file_name = os.path.basename(json_file_path)
        file_name_head = os.path.splitext(json_file_name)[0]
        yield json_file_name


def load_regles_file(json_file_name):
    regles_nodes = read_ast_json_file(json_file_name)
    regles_nodes = filter(
        lambda node: 'batch' in node['applications'] or 'iliad' in node['applications'],
        regles_nodes,
        )
    formula_name_and_source_pairs = mapcat(python_source_visitors.visit_node, regles_nodes)
    return formula_name_and_source_pairs


def load_verifs_file(json_file_name):
    verifs_nodes = read_ast_json_file(json_file_name)
    verifs_nodes = filter(
        lambda node: 'batch' in node['applications'] or 'iliad' in node['applications'],
        verifs_nodes,
        )
    verif_functions_sources = map(python_source_visitors.visit_node, verifs_nodes)
    return verif_functions_sources


# Main


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('-d', '--debug', action='store_true', default=False, help='Display debug messages')
    parser.add_argument('-v', '--verbose', action='store_true', default=False, help='Increase output verbosity')
    parser.add_argument('json_dir', help='Directory containing the JSON AST and data files')
    global args
    args = parser.parse_args()
    logging.basicConfig(
        level=logging.DEBUG if args.debug else (logging.INFO if args.verbose else logging.WARNING),
        stream=sys.stdout,
        )

    if not os.path.isdir(generated_dir_path):
        os.mkdir(generated_dir_path)

    # Transpile constants

    constants_file_name = os.path.join('data', 'constants.json')
    constants = read_json_file(json_file_name=constants_file_name)
    constants_source = pipe(
        constants.items(),
        sorted,
        map(lambda item: '{} = {}'.format(*item)),
        as_lines,
        )
    write_source_file(
        file_name='constants.py',
        source=constants_source,
        )

    # Transpile variables definitions

    variables_definitions_file_name = os.path.join('data', 'variables_definitions.json')
    variable_definition_by_name = read_json_file(json_file_name=variables_definitions_file_name)
    write_source_file(
        file_name='variables_definitions.py',
        source='variable_definition_by_name = {}\n'.format(pprint.pformat(variable_definition_by_name, width=120)),
        )

    # # Transpile verification functions
    #
    # verif_functions_sources = list(
    #     mapcat(load_verifs_file, iter_ast_json_file_names(filenames=['coc*.json', 'coi*.json']))
    #     )
    # verif_regles_source = as_lines((
    #     'from ..formulas_helpers import *',
    #     'from . import chap_ini_formulas\n',
    #     'def get_error(code):',
    #     '    return code',
    #     'def verif_regles(base_variables, saisie_variables):',
    #     '    results = chap_ini_formulas.compute(base_variables=base_variables, saisie_variables=saisie_variables)',
    #     '    globals().update(results)',
    #     textwrap.indent(''.join(verif_functions_sources), prefix=4 * ' '),
    #     ))
    # write_source_file(
    #     file_name='verif_regles.py',
    #     source=verif_regles_source,
    #     )

    # Read formulas order

    ordered_formulas_names = read_json_file(json_file_name=os.path.join('data', 'ordered_formulas.json'))

    # Transpile formulas

    formula_name_and_source_pairs = list(mapcat(
        load_regles_file,
        iter_ast_json_file_names(filenames=['chap-*.json', 'res-ser*.json']),
        ))
    source_by_formula_name = {}
    for formula_name, source in formula_name_and_source_pairs:
        if formula_name not in variable_definition_by_name:
            log.warning('Formula "{}" has no definition.'.format(formula_name))
        else:
            applications = variable_definition_by_name[formula_name]['applications']
            if formula_name not in source_by_formula_name or 'batch' in applications:
                if formula_name in source_by_formula_name and 'batch' in applications:
                    log.warning('Formula "{}" already met from another application, '
                                'but this one of "batch" is prefered => keep the source of this one ({}).'.format(
                                    formula_name, source))
                source_by_formula_name[formula_name] = source


    def get_formula_source(formula_name):
        sanitized_formula_name = python_source_visitors.sanitized_variable_name(formula_name)
        return source_by_formula_name[sanitized_formula_name] \
            if sanitized_formula_name in source_by_formula_name \
            else ('# WARNING: the variable "{name}" is used in a formula at least, but is not defined.\n' +
                'def {name}(): return 0').format(name=sanitized_formula_name)

    write_source_file(
        file_name='formulas.py',
        source=formulas_file_source(map(get_formula_source, ordered_formulas_names)),
        )

    return 0


if __name__ == '__main__':
    sys.exit(main())
