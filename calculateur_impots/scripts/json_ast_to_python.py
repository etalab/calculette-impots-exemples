#!/usr/bin/env python3
# -*- coding: utf-8 -*-


"""
Transpile (roughly means convert) a JSON AST file to Python source code.
"""


from operator import itemgetter
import argparse
import collections
import copy
import glob
import itertools
import json
import logging
import os
import pprint
import sys
import textwrap


# Globals


args = None
script_name = os.path.splitext(os.path.basename(__file__))[0]
log = logging.getLogger(script_name)

script_dir_path = os.path.dirname(os.path.abspath(__file__))
generated_dir_path = os.path.abspath(os.path.join(script_dir_path, '..', 'generated'))


# Python helpers

list_ = list  # To use in ipdb since "list" is reserved to display the current source code.

def mapcat(function, sequence):
    return itertools.chain.from_iterable(map(function, sequence))


# Source code helper functions


def read_ast_json_file(json_file_name):
    json_file_path = os.path.join(args.json_dir, json_file_name)
    with open(json_file_path) as json_file:
        json_str = json_file.read()
    nodes = json.loads(json_str)
    assert isinstance(nodes, list)
    return nodes


def sanitized_variable_name(value):
    # Python variables must not begin with a digit.
    return '__' + value if value[0].isdigit() else value


def value_to_python_source(value):
    return pprint.pformat(value, width=120)


def write_source(file_name, json_file_name, original_file_name, transpilation_function):
    header = """\
# -*- coding: utf-8 -*-
# flake8: noqa


# WARNING: This file is automatically generated by a script. No not modify it by hand!

# Original files are "{}" and "{}"


""".format(json_file_name, original_file_name)
    global args
    file_path = os.path.join(generated_dir_path, file_name)
    if os.path.exists(file_path) and not args.force and args.json is None:
        log.info('Output file "{}" exists => skip.'.format(file_path))
    elif args.json is None or json_file_name in args.json:
        log.debug(
            'Transpiling JSON file "{}" with function "{}"'.format(json_file_name, transpilation_function.__name__),
            )
        source = transpilation_function(json_file_name)
        with open(file_path, 'w') as output_file:
            output_file.write(header + source)
        log.info('Output file "{}" was written with success.'.format(file_path))


# General transpilation functions


def loop_variables_names(loop_variables_groups):
    return set(map(
        itemgetter('name'),
        mapcat(
            itemgetter('loop_variables'),
            loop_variables_groups,
            ),
        ))


def infix_expression_to_python_source(node, operators={}):
    def merge(*iterables):
        for values in itertools.zip_longest(*iterables, fillvalue=UnboundLocalError):
            for index, value in enumerate(values):
                if value != UnboundLocalError:
                    yield index, value

    tokens = (
        node_to_python_source(operand_or_operator)
        if index == 0
        else operators.get(operand_or_operator, operand_or_operator)
        for index, operand_or_operator in merge(node['operands'], node['operators'])
        )
    return ' '.join(map(str, tokens))


def iter_nodes(node, type):
    """
    Iterates over all nodes matching `type` recursively in `node`.
    """
    if isinstance(node, dict):
        if node['type'] == type:
            yield node
        else:
            yield from iter_nodes(node=list(node.values()), type=type)
    elif isinstance(node, list):
        for child_node in node:
            if isinstance(child_node, (list, dict)):
                yield from iter_nodes(node=child_node, type=type)


class TranspilationError(Exception):
    pass


deep_level = 0


def node_to_python_source(node, parenthesised=False):
    """
    Main transpilation function which calls the specific transpilation functions below.
    They are subfunctions to ensure they are never called directly.
    """

    def boolean_expression_to_python_source(node):
        return infix_expression_to_python_source(node, operators={'et': 'and', 'ou': 'or'})

    def comparaison_to_python_source(node):
        return '{} {} {}'.format(
            node_to_python_source(node['left_operand']),
            {'=': '=='}.get(node['operator'], node['operator']),
            node_to_python_source(node['right_operand']),
            )

    def dans_to_python_source(node):
        if not all(option['type'] == 'symbol' for option in node['options']):
            raise NotImplementedError(node)
        return '{} in {}'.format(
            node_to_python_source(node['expression'], parenthesised=True),
            '({})'.format(', '.join(option['value'] for option in node['options']))
            )

    def expression_to_python_source(node):
        return node_to_python_source(node)

    def float_to_python_source(node):
        return str(node['value'])

    def formula_to_python_source(node):
        # def iter_unlooped_parameters(loop_expression_nodes, symbol_nodes):
        #     for loop_expression_node in loop_expression_nodes:
        #         for loop_variable_node in loop_expression_node['loop_variables']:
        #             for symbol_node in symbol_nodes:
        #                 loop_variable_name = loop_variable_node['name']
        #                 symbol_name = symbol_node['value']
        #                 if loop_variable_name in symbol_name:
        #                     for domain_node in loop_variable_node['domains']:
        #                         if domain_node['type'] == 'symbol':
        #                             yield symbol_name.replace(loop_variable_name, domain_node['value'], 1)
        #                         elif domain_node['type'] == 'integer_range':
        #                             for index in range(domain_node['first'], domain_node['last'] + 1):
        #                                 yield symbol_name.replace(loop_variable_name, str(index), 1)
        #                 else:
        #                     yield symbol_node['value']
        #
        # parameters = sorted(set(
        #     iter_unlooped_parameters(
        #         loop_expression_nodes=iter_nodes(node=node['expression'], type='loop_expression'),
        #         symbol_nodes=iter_nodes(node=node['expression'], skip_type='loop_variable', type='symbol')
        #         ),
        #     ))
        expression_source = node_to_python_source(node['expression'])
        return '{name} = {expression}'.format(
            expression=expression_source,
            name=sanitized_variable_name(node['name']),
            # parameters=', '.join(parameters),
            )

    def function_call_to_python_source(node):
        return '{name}({arguments})'.format(
            arguments=', '.join(map(node_to_python_source, node['arguments'])),
            name=node['name'],
            )

    def indexed_formula_to_python_source(node):
        def iter_body(loop_variables_groups):
            for index, loop_variable_group in enumerate(loop_variables_groups):
                expression_node = loop_variable_group['expression']
                loop_variables_nodes = loop_variable_group['loop_variables']
                yield '{} {}:\n        return {}'.format(
                    'if' if index == 0 else 'elif',
                    ' or '.join(map(node_to_python_source, loop_variables_nodes)),
                    node_to_python_source(expression_node),
                    )
            yield 'else:\n        raise NotImplementedError()'
        parameters = loop_variables_names(loop_variables_groups=node['loop_variables_groups'])
        return 'def {name}({parameters}):\n    {body}'.format(
            body='\n    '.join(iter_body(loop_variables_groups=node['loop_variables_groups'])),
            name=node['name'],
            parameters=', '.join(sorted(parameters)),
            )


        # def create_unlooped_formula_node(formula_node, loop_variable_name):
        #     new_formula_node = copy.deepcopy(formula_node)
        #     new_formula_node['name'] = formula_node['name'].replace(loop_variable_name, loop_variable_value, 1)
        #     update_symbols(
        #         node=new_formula_node,
        #         loop_variable_name=loop_variable_name,
        #         loop_variable_value='({})'.format(loop_variable_name),
        #         )
        #     return new_formula_node
        #
        # def iter_unlooped_formulas(formula_node, loop_variable_domain_nodes, loop_variable_name):
        #     """
        #     Yield many formulas given one formula and a loop variable name and domains (symbols and/or integer ranges).
        #     The loop_variable_name is replaced in the formula name.
        #     """
        #     # Do not use "in" operator, strictly check for 1 occurence.
        #     assert formula_node['name'].count(loop_variable_name) == 1, (loop_variable_name, formula_node)
        #     for domain_node in loop_variable_domain_nodes:
        #         if domain_node['type'] == 'symbol':
        #             yield create_unlooped_formula_node(
        #                 formula_node=formula_node,
        #                 loop_variable_name=loop_variable_name,
        #                 loop_variable_value=domain_node['value'],
        #                 )
        #         elif domain_node['type'] == 'integer_range':
        #             for index in range(domain_node['first'], domain_node['last'] + 1):
        #                 yield create_unlooped_formula_node(
        #                     formula_node=formula_node,
        #                     loop_variable_name=loop_variable_name,
        #                     loop_variable_value=str(index),
        #                     )
        #         else:
        #             raise NotImplementedError('Unknown type for domain_node = {}'.format(domain_node))

        # formulas = itertools.chain.from_iterable(
        #     iter_unlooped_formulas(
        #         formula_node=node['formula'],
        #         loop_variable_domain_nodes=loop_variable_node['domains'],
        #         loop_variable_name=loop_variable_node['name'],
        #         )
        #     for loop_variable_node in node['loop_variables']
        #     )
        # return (2 * '\n').join(map(node_to_python_source, formulas))

    def integer_range_to_python_source(node):
        return 'interval({}, {})'.format(node['first'], node['last'])

    def integer_to_python_source(node):
        return str(node['value'])

    def loop_expression_to_python_source(node):
        def create_unlooped_expression_node(expression_node, loop_variable_name):
            new_expression_node = copy.deepcopy(node['expression'])
            update_symbols(
                node=new_expression_node,
                loop_variable_name=loop_variable_name,
                loop_variable_value='({})'.format(loop_variable_name),
                )
            return new_expression_node

        if len(node['loop_variables']) > 1:
            raise NotImplementedError()
        loop_variable_node = node['loop_variables'][0]

        return '({} for {} in {})'.format(
            node_to_python_source(create_unlooped_expression_node(
                expression_node=node['expression'],
                loop_variable_name=loop_variable_node['name'],
                )),
            loop_variable_node['name'],
            node_to_python_source(loop_variable_node),
            )

    def loop_variable_enumeration_to_python_source(node):
        return str(tuple(node['values']))

    def loop_variable_to_python_source(node):
        return ' or '.join(
            '{} in {}'.format(
                node['name'],
                node_to_python_source(domain_node),
                )
            for domain_node in node['domains']
            )

    def product_expression_to_python_source(node):
        return infix_expression_to_python_source(node)

    def regle_to_python_source(node):
        def without_loop_variables(name, loop_variables_groups):
            new_name = name
            for loop_variable_name in loop_variables_names(loop_variables_groups):
                new_name = new_name.replace(loop_variable_name, '', 1)
            return new_name

        pour_formulas_nodes = filter(lambda formula_node: formula_node['type'] == 'pour_formula', node['formulas'])
        loop_variables_groups_by_formula_name = collections.defaultdict(list)
        for pour_formula_node in pour_formulas_nodes:
            expression_node = pour_formula_node['formula']['expression']
            loop_variables_nodes = pour_formula_node['loop_variables']
            formula_node = pour_formula_node['formula']
            formula_name = formula_node['name']
            loop_variables_groups_by_formula_name[formula_name].append({
                'expression': formula_node['expression'],
                'loop_variables': loop_variables_nodes,
                })
        indexed_formulas_nodes = (
            {
                'loop_variables_groups': loop_variables_groups,
                'name': without_loop_variables(
                    loop_variables_groups=loop_variables_groups,
                    name=formula_name,
                    ),
                'type': 'indexed_formula',
                }
            for formula_name, loop_variables_groups in loop_variables_groups_by_formula_name.items()
            )
        formulas_nodes = filter(lambda formula_node: formula_node['type'] == 'formula', node['formulas'])
        all_formulas_nodes = itertools.chain(formulas_nodes, indexed_formulas_nodes)
        return (3 * '\n').join(map(node_to_python_source, all_formulas_nodes)) + '\n'

    def sum_expression_to_python_source(node):
        return infix_expression_to_python_source(node)

    def symbol_to_python_source(node):
        return sanitized_variable_name(node['value'])

    def ternary_operator_to_python_source(node):
        return '{} if {} else {}'.format(
            node_to_python_source(node['value_if_true'], parenthesised=True),
            node_to_python_source(node['condition'], parenthesised=True),
            node_to_python_source(node['value_if_false'], parenthesised=True) if 'value_if_false' in node else 0,
            )

    global deep_level
    transpilation_function_name = node['type'] + '_to_python_source'
    if transpilation_function_name not in locals():
        error_message = '"def {}(node):" is not defined, node = {}'.format(
            transpilation_function_name,
            value_to_python_source(node),
            )
        raise NotImplementedError(error_message)
    nb_prefix_chars = len('DEBUG:' + script_name) + 1
    node_str = textwrap.indent(
        json.dumps(node, indent=4),
        prefix='>' * nb_prefix_chars + ' ' * deep_level * 4,
        )[nb_prefix_chars:].lstrip()
    log.debug(
        '{}{}({})'.format(
            ' ' * deep_level * 4 + '={}=> '.format(deep_level),
            transpilation_function_name,
            node_str,
            )
        )
    transpilation_function = locals()[transpilation_function_name]
    deep_level += 1
    try:
        source = transpilation_function(node)
    except (NotImplementedError, TranspilationError):
        # Bubble up all nested calls of node_to_python_source.
        raise
    except Exception:  # We really want to catch all exceptions to debug.
        raise TranspilationError(value_to_python_source(node))
    assert isinstance(source, str), (source, node)
    if parenthesised and node['type'] not in ('integer', 'float', 'string', 'symbol'):
        source = '({})'.format(source)
    deep_level -= 1
    log.debug(
        '{}<={}= {}'.format(
            ' ' * deep_level * 4,
            deep_level,
            textwrap.indent(source, prefix='> ')[1:].lstrip(),
            )
        )
    assert deep_level >= 0, deep_level
    return source


def update_symbols(node, loop_variable_name, loop_variable_value):
    """
    Replace `loop_variable_name` by `loop_variable_value` in symbols recursively found in `node`.
    This function mutates `node` and returns nothing.
    """
    if isinstance(node, dict):
        if node['type'] == 'symbol':
            node['value'] = node['value'].replace(loop_variable_name, loop_variable_value, 1)
        else:
            update_symbols(list(node.values()), loop_variable_name, loop_variable_value)
    elif isinstance(node, list):
        for child_node in node:
            update_symbols(child_node, loop_variable_name, loop_variable_value)


# File transpilation functions


def chap_to_python_source(json_file_name):
    global args
    regle_nodes = list(filter(
        lambda node: args.application in node['applications'],
        read_ast_json_file(json_file_name),
        ))
    source = '\n'.join(map(node_to_python_source, regle_nodes))
    return source


def tgvH_json_to_python_source(json_file_name):
    nodes = read_ast_json_file(json_file_name)
    variable_definition_by_name = {
        node['name']: node
        for node in nodes
        if node['type'] in ('variable_calculee', 'variable_saisie')
        }
    source = 'variable_definition_by_name = ' + value_to_python_source(variable_definition_by_name)
    return source


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('--application', default='batch', help='Application name')
    parser.add_argument('-d', '--debug', action='store_true', default=False, help='Display debug messages')
    parser.add_argument('-f', '--force', action='store_true', default=False, help='Transpile files which exist')
    parser.add_argument('--json', nargs='+', help='Transpile these JSON files only (give only file name)')
    parser.add_argument('-v', '--verbose', action='store_true', default=False, help='Increase output verbosity')
    parser.add_argument('json_dir', help='Directory containing the JSON AST files')
    global args
    args = parser.parse_args()
    logging.basicConfig(
        level=logging.DEBUG if args.debug else (logging.INFO if args.verbose else logging.WARNING),
        stream=sys.stdout,
        )

    if args.json is not None:
        for json_file_name in args.json:
            json_file_path = os.path.join(args.json_dir, json_file_name)
            if not os.path.exists(json_file_path):
                parser.error('JSON file "{}" does not exist.'.format(json_file_path))

    if not os.path.isdir(generated_dir_path):
        os.mkdir(generated_dir_path)

    write_source(
        file_name='variables_definitions.py',
        json_file_name='tgvH.json',
        original_file_name='tgvH.m',
        transpilation_function=tgvH_json_to_python_source,
        )

    for json_file_path in sorted(glob.iglob(os.path.join(args.json_dir, 'chap-*.json'))):
        json_file_name = os.path.basename(json_file_path)
        file_name_head, _ = os.path.splitext(json_file_name)
        write_source(
            file_name=file_name_head.replace('-', '_') + '.py',
            json_file_name=json_file_name,
            original_file_name=file_name_head + '.m',
            transpilation_function=chap_to_python_source,
            )

    return 0


if __name__ == '__main__':
    sys.exit(main())
