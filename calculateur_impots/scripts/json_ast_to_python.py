#!/usr/bin/env python3
# -*- coding: utf-8 -*-


"""
Transpile (roughly means convert) a JSON AST file to Python source code.
"""


from operator import itemgetter
import argparse
import collections
import copy
import glob
import itertools
import json
import logging
import os
import pprint
import sys
import textwrap


# Globals


args = None
script_name = os.path.splitext(os.path.basename(__file__))[0]
log = logging.getLogger(script_name)

script_dir_path = os.path.dirname(os.path.abspath(__file__))
generated_dir_path = os.path.abspath(os.path.join(script_dir_path, '..', 'generated'))


# Python helpers

list_ = list  # To use in ipdb since "list" is reserved to display the current source code.

def mapcat(function, sequence):
    return itertools.chain.from_iterable(map(function, sequence))


# Source code helper functions


def read_ast_json_file(json_file_name):
    json_file_path = os.path.join(args.json_dir, json_file_name)
    with open(json_file_path) as json_file:
        json_str = json_file.read()
    nodes = json.loads(json_str)
    assert isinstance(nodes, list)
    return nodes


def sanitized_variable_name(value):
    # Python variables must not begin with a digit.
    return '__' + value if value[0].isdigit() else value


def value_to_python_source(value):
    return pprint.pformat(value, width=120)


def write_source(file_name, json_file_name, original_file_name, transpilation_function):
    header = """\
# -*- coding: utf-8 -*-
# flake8: noqa


# WARNING: This file is automatically generated by a script. No not modify it by hand!

# Original files are "{}" and "{}"


""".format(json_file_name, original_file_name)
    global args
    file_path = os.path.join(generated_dir_path, file_name)
    if os.path.exists(file_path) and not args.force and args.json is None:
        log.info('Output file "{}" exists => skip.'.format(file_path))
    elif args.json is None or json_file_name in args.json:
        log.info('Transpiling JSON file "{}" to Python file "{}"'.format(json_file_name, file_name))
        source = transpilation_function(json_file_name)
        with open(file_path, 'w') as output_file:
            output_file.write(header + source)


# General transpilation functions


def extract_loop_variables_names(loop_variables_groups):
    return set(map(
        itemgetter('name'),
        mapcat(
            itemgetter('loop_variables'),
            loop_variables_groups,
            ),
        ))


def infix_expression_to_python_source(node, operators={}):
    def merge(*iterables):
        for values in itertools.zip_longest(*iterables, fillvalue=UnboundLocalError):
            for index, value in enumerate(values):
                if value != UnboundLocalError:
                    yield index, value

    tokens = (
        node_to_python_source(operand_or_operator)
        if index == 0
        else operators.get(operand_or_operator, operand_or_operator)
        for index, operand_or_operator in merge(node['operands'], node['operators'])
        )
    return ' '.join(map(str, tokens))


def iter_nodes(node, type):
    """
    Iterates over all nodes matching `type` recursively in `node`.
    """
    if isinstance(node, dict):
        if node['type'] == type:
            yield node
        else:
            yield from iter_nodes(node=list(node.values()), type=type)
    elif isinstance(node, list):
        for child_node in node:
            if isinstance(child_node, (list, dict)):
                yield from iter_nodes(node=child_node, type=type)


class TranspilationError(Exception):
    pass


deep_level = 0


def node_to_python_source(node, parenthesised=False):
    """
    Main transpilation function which calls the specific transpilation functions below.
    They are subfunctions to ensure they are never called directly.
    """

    def boolean_expression_to_python_source(node):
        return infix_expression_to_python_source(node, operators={'et': 'and', 'ou': 'or'})

    def comparaison_to_python_source(node):
        return '{} {} {}'.format(
            node_to_python_source(node['left_operand']),
            {'=': '=='}.get(node['operator'], node['operator']),
            node_to_python_source(node['right_operand']),
            )

    def dans_to_python_source(node):
        return '{} {} {}'.format(
            node_to_python_source(node['expression'], parenthesised=True),
            'not in' if node.get('negative_form') else 'in',
            node['enumeration'],
            )

    def enumeration_values_to_python_source(node):
        return str(tuple(node['values']))

    def expression_to_python_source(node):
        return node_to_python_source(node)

    def float_to_python_source(node):
        return str(node['value'])

    def formula_to_python_source(node):
        expression_source = node_to_python_source(node['expression'])
        return '{name} = {expression}'.format(
            expression=expression_source,
            name=sanitized_variable_name(node['name']),
            )

    def function_call_to_python_source(node):
        return '{name}({arguments})'.format(
            arguments=', '.join(map(node_to_python_source, node['arguments'])),
            name=node['name'],
            )

    def indexed_formula_to_python_source(node):
        def iter_body():
            for index, loop_variable_group in enumerate(node['loop_variables_groups']):
                loop_variables_nodes = loop_variable_group['loop_variables']
                yield '{} {}:\n        return {}'.format(
                    'if' if index == 0 else 'elif',
                    ' or '.join(map(node_to_python_source, loop_variables_nodes)),
                    node_to_python_source(unlooped(
                        loop_variables_names=loop_variables_names,
                        node=loop_variable_group['expression'],
                        )),
                    )
            yield 'else:\n        raise NotImplementedError()'
        loop_variables_names = extract_loop_variables_names(loop_variables_groups=node['loop_variables_groups'])
        return 'def {name}({parameters}):\n    {body}'.format(
            body='\n    '.join(iter_body()),
            parameters=', '.join(sorted(loop_variables_names)),
            name=node['name'],
            )

    def integer_to_python_source(node):
        return str(node['value'])

    def interval_to_python_source(node):
        return 'interval({}, {})'.format(node['first'], node['last'])

    def loop_expression_to_python_source(node):
        if len(node['loop_variables']) > 1:
            raise NotImplementedError()
        loop_variable_node = node['loop_variables'][0]
        return '({} for {})'.format(
            node_to_python_source(unlooped(
                loop_variables_names=[loop_variable_node['name']],
                node=node['expression'],
                )),
            node_to_python_source(loop_variable_node),
            )

    def loop_variable_to_python_source(node):
        return ' or '.join(
            '{} in {}'.format(
                node['name'],
                node_to_python_source(enumerations_node),
                )
            for enumerations_node in node['enumerations']
            )

    def product_expression_to_python_source(node):
        return infix_expression_to_python_source(node)

    def regle_to_python_source(node):
        def without_loop_variables(name, loop_variables_groups):
            new_name = name
            for loop_variable_name in extract_loop_variables_names(loop_variables_groups):
                new_name = new_name.replace(loop_variable_name, '', 1)
            return new_name

        pour_formulas_nodes = filter(lambda formula_node: formula_node['type'] == 'pour_formula', node['formulas'])
        loop_variables_groups_by_formula_name = collections.defaultdict(list)
        for pour_formula_node in pour_formulas_nodes:
            loop_variables_nodes = pour_formula_node['loop_variables']
            formula_node = pour_formula_node['formula']
            formula_name = formula_node['name']
            loop_variables_groups_by_formula_name[formula_name].append({
                'expression': formula_node['expression'],
                'loop_variables': loop_variables_nodes,
                })
        indexed_formulas_nodes = (
            {
                'loop_variables_groups': loop_variables_groups,
                'name': without_loop_variables(
                    loop_variables_groups=loop_variables_groups,
                    name=formula_name,
                    ),
                'type': 'indexed_formula',
                }
            for formula_name, loop_variables_groups in loop_variables_groups_by_formula_name.items()
            )
        formulas_nodes = filter(lambda formula_node: formula_node['type'] == 'formula', node['formulas'])
        all_formulas_nodes = itertools.chain(formulas_nodes, indexed_formulas_nodes)
        return (3 * '\n').join(map(node_to_python_source, all_formulas_nodes)) + '\n'

    def sum_expression_to_python_source(node):
        return infix_expression_to_python_source(node)

    def symbol_to_python_source(node):
        return sanitized_variable_name(node['value'])

    def ternary_operator_to_python_source(node):
        return '{} if {} else {}'.format(
            node_to_python_source(node['value_if_true'], parenthesised=True),
            node_to_python_source(node['condition'], parenthesised=True),
            node_to_python_source(node['value_if_false'], parenthesised=True) if 'value_if_false' in node else 0,
            )

    global deep_level
    transpilation_function_name = node['type'] + '_to_python_source'
    if transpilation_function_name not in locals():
        error_message = '"def {}(node):" is not defined, node = {}'.format(
            transpilation_function_name,
            value_to_python_source(node),
            )
        raise NotImplementedError(error_message)
    nb_prefix_chars = len('DEBUG:' + script_name) + 1
    transpilation_function_short_name = transpilation_function_name[:-len('to_python_source') - 1]
    prefix = '> {}{}'.format(
        transpilation_function_short_name + ' ' * (nb_prefix_chars - len(transpilation_function_short_name) - 3) + ':',
        ' ' * deep_level * 4,
        )
    node_str = textwrap.indent(json.dumps(node, indent=4), prefix=prefix)[nb_prefix_chars:].lstrip()
    log.debug(
        '{}{}({})'.format(
            ' ' * deep_level * 4 + '={}=> '.format(deep_level),
            transpilation_function_name,
            node_str,
            )
        )
    transpilation_function = locals()[transpilation_function_name]
    deep_level += 1
    try:
        source = transpilation_function(node)
    except (NotImplementedError, TranspilationError):
        # Bubble up all nested calls of node_to_python_source.
        raise
    except Exception:  # We really want to catch all exceptions to debug.
        raise TranspilationError(value_to_python_source(node))
    assert isinstance(source, str), (source, node)
    if parenthesised and node['type'] not in ('integer', 'float', 'string', 'symbol'):
        source = '({})'.format(source)
    deep_level -= 1
    log.debug(
        '{}<={}= {}'.format(
            ' ' * deep_level * 4,
            deep_level,
            textwrap.indent(source, prefix='> ')[1:].lstrip(),
            )
        )
    assert deep_level >= 0, deep_level
    return source


def unlooped(node, loop_variables_names):
    new_node = copy.deepcopy(node)
    update_symbols(current_node=new_node, loop_variables_names=loop_variables_names)
    return new_node


def update_symbols(current_node, loop_variables_names):
    """
    Replace loop variables names contained in variable name by a function call with arguments,
    in symbols recursively found in `current_node`.
    This function mutates `current_node` and returns nothing. Better use the `unlooped` function.
    Examples: ABCi => ABC(i), ABCij => ABC(i, j)
    """
    if isinstance(current_node, dict):
        if current_node['type'] == 'symbol':
            current_node['value'] = current_node['value'].replace(
                ''.join(loop_variables_names),
                '({})'.format(', '.join(loop_variables_names)),
                1,
                )
        else:
            update_symbols(current_node=list(current_node.values()), loop_variables_names=loop_variables_names)
    elif isinstance(current_node, list):
        for child_node in current_node:
            update_symbols(current_node=child_node, loop_variables_names=loop_variables_names)


# File transpilation functions


def chap_to_python_source(json_file_name):
    global args
    regle_nodes = list(filter(
        lambda node: args.application in node['applications'],
        read_ast_json_file(json_file_name),
        ))
    source = '\n'.join(map(node_to_python_source, regle_nodes))
    return source


def tgvH_json_to_python_source(json_file_name):
    nodes = read_ast_json_file(json_file_name)
    variable_definition_by_name = {
        node['name']: node
        for node in nodes
        if node['type'] in ('variable_calculee', 'variable_saisie')
        }
    source = 'variable_definition_by_name = ' + value_to_python_source(variable_definition_by_name)
    return source


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('--application', default='batch', help='Application name')
    parser.add_argument('-d', '--debug', action='store_true', default=False, help='Display debug messages')
    parser.add_argument('-f', '--force', action='store_true', default=False, help='Transpile files which exist')
    parser.add_argument('--json', nargs='+', help='Transpile these JSON files only (give only file name)')
    parser.add_argument('-v', '--verbose', action='store_true', default=False, help='Increase output verbosity')
    parser.add_argument('json_dir', help='Directory containing the JSON AST files')
    global args
    args = parser.parse_args()
    logging.basicConfig(
        level=logging.DEBUG if args.debug else (logging.INFO if args.verbose else logging.WARNING),
        stream=sys.stdout,
        )

    if args.json is not None:
        for json_file_name in args.json:
            json_file_path = os.path.join(args.json_dir, json_file_name)
            if not os.path.exists(json_file_path):
                parser.error('JSON file "{}" does not exist.'.format(json_file_path))

    if not os.path.isdir(generated_dir_path):
        os.mkdir(generated_dir_path)

    # chap-n

    for json_file_path in sorted(glob.iglob(os.path.join(args.json_dir, 'chap-*.json'))):
        json_file_name = os.path.basename(json_file_path)
        file_name_head = os.path.splitext(json_file_name)[0]
        write_source(
            file_name=file_name_head.replace('-', '_') + '.py',
            json_file_name=json_file_name,
            original_file_name=file_name_head + '.m',
            transpilation_function=chap_to_python_source,
            )

    # tgvH

    write_source(
        file_name='variables_definitions.py',
        json_file_name='tgvH.json',
        original_file_name='tgvH.m',
        transpilation_function=tgvH_json_to_python_source,
        )

    return 0


if __name__ == '__main__':
    sys.exit(main())
