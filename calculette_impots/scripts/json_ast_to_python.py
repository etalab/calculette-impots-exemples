#!/usr/bin/env python3
# -*- coding: utf-8 -*-


"""
Transpile (roughly means convert) a JSON AST file to Python source code.
"""


from operator import itemgetter
from string import Template
import argparse
import copy
import glob
import itertools
import json
import logging
import os
import pkg_resources
import pprint
import sys
import textwrap

from toolz.curried import concat, concatv, filter, first, map, mapcat, pipe, sorted, valmap

from calculette_impots import formulas_helpers, loaders, python_source_visitors
from calculette_impots.variables_definitions import VariablesDefinitions


# Globals


args = None
script_name = os.path.splitext(os.path.basename(__file__))[0]
log = logging.getLogger(script_name)

script_dir_path = os.path.dirname(os.path.abspath(__file__))
generated_dir_path = os.path.abspath(os.path.join(script_dir_path, '..', 'generated'))


# Functions to write source code files


def as_lines(sequence):
    return ''.join(concat(zip(sequence, itertools.repeat('\n'))))


def write_source_file(file_name, source):
    header = """\
# -*- coding: utf-8 -*-
# flake8: noqa
# WARNING: This file is automatically generated by a script. No not modify it by hand!
"""
    file_path = os.path.join(generated_dir_path, file_name)
    with open(file_path, 'w') as output_file:
        output_file.write(as_lines((header, source)))
    log.info('Output file "{}" written with success'.format(file_path))


# Functions to read JSON data files


def iter_ast_json_file_names(filenames):
    json_file_paths = pipe(
        filenames,
        map(lambda pathname: os.path.join(args.json_dir, 'ast', pathname)),
        mapcat(glob.iglob),
        sorted,
        )
    for json_file_path in json_file_paths:
        json_file_name = os.path.basename(json_file_path)
        file_name_head = os.path.splitext(json_file_name)[0]
        yield json_file_name


def load_regles_file(json_file_name):
    return pipe(
        read_ast_json_file(json_file_name),
        filter(lambda node: 'batch' in node['applications']),
        mapcat(python_source_visitors.visit_node),
        )


def load_verifs_file(json_file_name):
    return pipe(
        read_ast_json_file(json_file_name),
        filter(lambda node: 'batch' in node['applications']),
        map(python_source_visitors.visit_node),
        )


def read_ast_json_file(json_file_name):
    nodes = read_json_file(os.path.join('ast', json_file_name))
    assert isinstance(nodes, list)
    return nodes


def read_json_file(json_file_name):
    json_file_path = os.path.abspath(os.path.join(args.json_dir, json_file_name))
    log.info('Loading "{}"...'.format(json_file_path))
    with open(json_file_path) as json_file:
        json_str = json_file.read()
    return json.loads(json_str)


# Main


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('-d', '--debug', action='store_true', default=False, help='Display debug messages')
    parser.add_argument('-v', '--verbose', action='store_true', default=False, help='Increase output verbosity')
    parser.add_argument('json_dir', help='Directory containing the JSON AST and data files')
    global args
    args = parser.parse_args()
    logging.basicConfig(
        level=logging.DEBUG if args.debug else (logging.INFO if args.verbose else logging.WARNING),
        stream=sys.stdout,
        )

    if not os.path.exists(args.json_dir):
        parser.error('json_dir {!r} does not exist'.format(args.json_dir))

    if not os.path.isdir(generated_dir_path):
        os.mkdir(generated_dir_path)

    # Initialize a variables_definitions object and set global variable in visitors

    variables_definitions = python_source_visitors.variables_definitions = VariablesDefinitions()

    # Transpile verification functions

    verif_sources = list(
        mapcat(load_verifs_file, iter_ast_json_file_names(filenames=['coc*.json', 'coi*.json']))
        )
    verifs_source = Template("""\
from ..formulas_helpers import arr, cached, inf, interval, null, positif, positif_ou_nul, present, somme


def get_errors(formulas, saisie_variables):
    errors = []

$verifs
    return errors or None
""").substitute(verifs=textwrap.indent('\n'.join(verif_sources), prefix=4 * ' '))
    write_source_file(
        file_name='verifs.py',
        source=verifs_source,
        )

    # Transpile formulas

    constants = loaders.load_constants()
    source_by_formula_name = dict(list(mapcat(
        load_regles_file,
        iter_ast_json_file_names(filenames=['chap-*.json', 'res-ser*.json']),
        )))

    def get_formula_source(variable_name):
        source = source_by_formula_name.get(variable_name)
        if source is not None:
            return source
        if variables_definitions.is_saisie(variable_name):
            return python_source_visitors.make_formula_source(
                expression='saisie_variables.get({!r}, 0)'.format(variable_name),
                formula_name=variable_name,
                )
        if variable_name in constants:
            return python_source_visitors.make_formula_source(
                expression='constants[{!r}]'.format(variable_name),
                formula_name=variable_name,
                )
        if variables_definitions.is_calculee(variable_name):
            if not variables_definitions.is_calculee(variable_name, kind='base'):
                log.debug('Variable {!r} is declared in tgvH file but has no formula'.format(variable_name))
            return python_source_visitors.make_formula_source(
                expression='0',
                formula_name=variable_name,
                )
        assert False, variable_name

    # Merge variable names coming from dependencies graph and variables definitions
    # because some variables are missing in tgvH file;
    # or some constants are declared in tgvH but are not used in formulas, only in verifs.
    dependencies_by_formula_name = loaders.load_formulas_dependencies()
    all_variable_names = set(concatv(
        dependencies_by_formula_name.keys(),
        concat(dependencies_by_formula_name.values()),
        variables_definitions.definition_by_variable_name.keys(),
        constants.keys(),
        ))
    write_source_file(
        file_name='formulas.py',
        source=Template("""\
from __future__ import division

import inspect

from ..formulas_helpers import arr, cached, inf, interval, null, positif, positif_ou_nul, present, somme


def get_formulas(cache, constants, saisie_variables):
    formulas = {}

$formulas
    return formulas
""").substitute(
            formulas=textwrap.indent(
                '\n'.join(map(get_formula_source, sorted(all_variable_names))),
                prefix=4 * ' ',
                ),
            ),
        )

    return 0


if __name__ == '__main__':
    sys.exit(main())
